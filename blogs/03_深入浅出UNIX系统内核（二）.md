# 深入浅出UNIX系统内核（二）



## 三、进程调度

#### 1、进程调度是什么？

CPU必须是一种被所有进程共享的资源。内核中安排进程间可用CPU时间的部分叫做调度器。传统的UNIX调度器使用抢占式轮转调度策略。具有相同优先级的进程以轮转的方式被调度，每个进程运行的时间是一个固定的时间配额。如果一个更高优先级的进程变为可运行时，它会抢占当前进程，无论当前进程是否使用完它的时间配额。

#### 2、传统的UNIX调度（SVR3和4.3BSD）
传统的UNIX调度是基于优先级的，每个进程有一个随时间改变的调度优先级。调度器总是选择优先级最高且处于可运行状态的进程。它使用可抢占的时间片来调度有相同优先级的进程，并根据进程的CPU使用模式来动态改变进程的优先级。如果一个高优先级的进程变为就绪状态，调度器就会抢占当前运行的进程，即使这个进程还没用完它的时间片或时间配额。

传统的UNIX内核是严格不可抢占的。如果一个进程正在执行内核代码（比如一个系统调用或中断），不能强迫它放弃CPU把CPU让给一个更高优先级的进程，只会因为阻塞在一个资源上时自愿的放弃CPU。否则，它只有返回用户态后可以被抢占。（解决多个进程访问相同内核数据结构相关的同步问题）

##### 进程优先级
进程优先级可以为0到127之间的任何数值。数值越低对应的优先级就越高。0到49之间的优先级是为内核保留的，所以用户态进程的优先级为50到127。proc结构里的以下字段包含了与优先级相关的信息：

* p_pri  当前调度优先级 
* p_usrpri 用户态优先级
* p_cpu 最近CPU使用的度量
* p_nice 用户可控的nice因子

调度器通过p_pri来决定调度哪个进程，当进程处于用户态时，它的p_pri和p_usrpri的值是一样的。当进程从阻塞在一个系统调用中被唤醒后，为了优先进入内核态处理，它的优先级会被提提高。因此，调度器使用p_usrpri来保存进程返回用户态时的必须赋予它的优先级，p_pri则用来保存它的临时内核优先级。

用户态的优先级取决于两个因素：nice因子值和最近的CPU使用情况。
计算公式： p_usrpri = PUSER + (p_cpu/4) + (2 * p_nice)

> PUSER是用户优先级基线，为50。
> 如果进程最近使用了大量的CPU时间，它的p_cpu因子将会增加，这回导致一个很大的p_usrpri的值的产生，从而降低了它的优先级。进程在被调度之前等待的时间越长，衰减因子就会更多的降低它的p_cpu，从而持续提升这个进程的优先级，这个机制可以防止低优先级进程被饿死。

##### 优点：
* 传统的调度算法简单且有效。他可以很好的满足一个混合着交互式程序和批处理作业的通用分时系统。
* 优先级的动态计算可以防止任何进程饿死。
##### 局限性：
* 传统调度器的伸缩性不是很好，如果进程的数目非常庞大，他就无法有效的在每秒去重新计算所有的优先级。

* 没法保证CPU资源的某一部分能够分配给指定的进程或进程组。

* 没法保证具有实时特性的应用程序的响应时间。

* 应用程序不能很好的控制自己的优先级，nice机制简洁，但存在不足。

* 因为内核是不可抢占的，高优先级的进程，可能需要等待一段显著的时间，即使它已经是处于可运行的状态。这称为优先级反转。

现代UNIX系统用在很多类型的环境中，特别是，对调度器支持实时应用程序，有着很大的需求。这些实时应用程序需要更多可预测的行为和严格的响应时间。这就需要重新设计调度器。


#### 3、SVR4调度器

基本的抽象概念是调度类（scheduling class），这为属于它的所有进程定义了调度策略。系统可以提供多个调度类。默认情况下，SVR4提供了两种调度类：分时（time-sharing）和实时（real-time）

实时类优先级高于分时类优先级

#### 4、Solaris 2.x调度的改善
Solaris 2.x 在多个方面改善了SVR4的基本调度体系结构。
* 可抢占的内核
* 多处理器支持
* 隐式调度
* 优先级反转
* 优先级继承

#### 5、Mach上的调度
Mach是多线程、多处理器的操作系统。它被设计用于运行在所有类型的机器上，涵盖了单处理器和包含上百个CPU但共享一个公共地址空间的大规模并行系统。
Mach上线程是基本的调度实体，Mach调度线程的时候，不用关心线程属于哪个任务。
每个线程从它所属的任务中继承了一个基本的调度优先级。这个优先级同CPU使用情况因子结合起来。

##### 处理器集合
Mach允许用户通过创建一个处理器集合来控制处理器的分配，每个集合可能包含零个或多个处理器。

##### 成组调度
在一个拥有大量处理器的大规模并行系统中，可以为一个单独的任务或者一组任务分配几个处理器，来保证这些任务所需的资源，而不用考虑系统的整体负载，在极端情况下，应用程序可以试图为它的每个线程，分别分配一个处理器，这就是成组调度。



## 四、进程间通讯（IPC）
在复杂的编程环境中经常使用多个互相协作的的进程来执行有关联的操作。这些进程需要彼此之间进行通信、共享资源和信息。为此，内核必须提供一些支持机制。这些机制统称为进程间通信，或IPC。

进程间交互的几个不同的目的：
* 数据传输
* 共享数据
* 事件通知
* 资源共享
* 进程控制

#### 通用的IPC方法：
信号、管道、进程跟踪

##### 信号
信号主要用来通知进程异步事件的发生

每个信号都有一个默认的处理动作，这个处理动作通常是终止进程。进程可以通过提供一个信号处理函数来对任何信号指定一个可选的响应，当信号发生时，内核会中断进程，进程执行信号处理函数来响应该信号。当信号处理函数完成时，进程可以恢复正常的处理。

信号的初衷主要是为了能够用信号来处理错误，例如，内核会将一些除以零或非法指令这样的硬件异常转换为信号。如果进程没有提供对这些异常的错误处理函数，内核就会终止该进程。

###### 信号的局限性：
1）信号的代价是昂贵的。发送者必须执行一个系统调用；内核必须中断接收者，并对接收者的栈进行大量操作，以便调用信号处理函数，并在随后恢复被中断的代码。
2）信号的带宽有限，只有31种不同的信号，每个信号能传送的信息量也是有限的，用户生成的信号无法发送额外的信息或者参数给接收者。尽管信号在事件通知上是非常有效地，但对更复杂一些的交互则无法胜任。

##### 管道：

传统实现上，管道是一个单向的、先进先出的、未结构化的、固定大小的数据流。写者往管道的尾部添加数据，读者从管道的首部接收数据。一旦数据被读走，数据就会从管道中移除，其他读者无法再读取这写数据。

通常情况下，管道都是被两个进程共享，每个进程拥有其中的一段。

###### 管道的局限性：
1）因为读取数据的同时会从管道移除数据，所以管道不能用于向给多个接收者广播数据。
2）管道里的数据被当做字节流，无法得知消息的边界。如果写者通过管道发送多个不同长度的对象时，读者不能确定已经发送了多少个对象，也无法确定某个对象何时结束和下一个对象合适结束。
3）如果管道上有多个读者，写者无法发送数据到特定读者。同样的，如果有多个写者，也无法确定是他们中的哪一个发送了数据。

##### 进程跟踪：

主要用在调试器上，通过使用ptrace，进程可以控制子进程的执行。

ptrace (cmd, pid, addr, data)

###### 局限性：
1）低效
2）无法跟踪一个正在运行的进程，因为子进程想要被跟踪时，它必须首先调用ptrance来通知内核。
。。。

#### System V IPC

三种IPC机制：信号量、消息队列和共享内存

#### Mach IPC 
在Mach上，IPC是核心，并且是内核中最重要的组件。

##### 基本概念：
Mach上两个基本的IPC抽象概念是消息（message）和端口（port）。消息是有类型的数据的集合，端口是一个受保护的消息队列。消息只能被发往一个端口，而不是发往任务或者线程。Mach赋予了每个端口的发送权利和接收权利（right），这些权利被任务所拥有。发送权利允许任务发送消息给该端口；接受权利允许接收那些发往该端口的消息。多个任务可以拥有对单个端口的发送权利，但只有一个任务，即端口的拥有者，持有接收的权利。因此，端口允许多对一的通讯。

![](https://github.com/Yanyuxxxx/Blogs/blob/master/images/03_%E7%94%A8Mach%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1.png?raw=true)

##### 消息
消息是有类型的数据的集合。它包含三种基本类型的数据：
* 普通数据
* out-of-line内存，被用来传输大量数据，使用写时复制技术。
* 端口的接收和发送权利 

消息有一个固定长度的头部，紧跟着一个变长的数据部分。

##### 消息头部
* type：简单（simple，只有普通数据）或复杂（complex，可能有out-of-line内存或端口权利）
* size：整个消息的大小（包含头部）
* destination port：目的端口
* reply port：答复端口，想发送答复的接收者对这个端口有发送权利；这个端口只在发送者需要答复时才被设置。
* message ID：应用程序可以根据需要使用

注：消息在它被发送之前是发送任务的地址空间中构造的，此时，目的端口和答复端口是本地端口名字。在传送这个消息之前，内核必须将这些端口转换为对接收者有意义的值。
![](https://github.com/Yanyuxxxx/Blogs/blob/master/images/03_Mach%E6%B6%88%E6%81%AF.png?raw=true)

##### 消息传递接口：
应用程序可以有多种不同的方式来使用消息传递
msg_send(), 发送消息，但不需要答复
msg_rcv()，等待非探测消息，在它们到达时处理它们
msg_rpc()，发送消息，并等待/期望答复

##### 端口
端口是受保护的消息队列。任务可以获得对端口的发送或接收权利。只有拥有合适的权利才能访问端口。虽然多个任务可以拥有对某个端口的发送权利，但只有一个任务能持有接收权利。持有接收权利的任务自动拥有对该端口的发送权利。

每个端口都有一个大小有限的消息队列，这个队列的大小提供了简单的流控制机制。发送者在队列满的时候会被阻塞，接收者在队列空的时候会被阻塞。
端口也可以用来表示像任务、线程、处理器这样的Mach对象。这些端口上的权利表示对象的引用，这样的引用允许持有者操作底层对象。内核持有对这些端口的接收权利。每个任务和线程都有一组默认的端口。例如，每个任务都有对表示他自己的task_self端口的发送权利（内核对这个端口有接收权利），还有对task_notify端口的接收权利（内核对这个端口有发送权利）。任务可以发送消息到task_self这个端口上来请求影响该任务的内核服务。如果另外一个任务，可能是个调试器，也有对这个端口的发送权利，他就可以通过发送消息到这个端口上来执行一些操作。每个线程都有对thread_self端口的发送权利，和对答复端口（reply port）的接收权利。答复端口被用来接收系统调用和对其他任务的远程过程调用的答复内容。每个任务和线程上还有一个异常（exception）端口。每个线程端口上的权利是被线程所在的任务拥有的；因此这些端口可以被任务里的所有线程访问。

##### 端口的命名空间
端口权利就是端口的名字，这个名字是简单的整数值，命名空间对于任务来说是本地的。因此，对于同一个端口，不同的任务可以有不同的名字。

每个端口还由一个全局的内核数据结构表示，内核必须将本地的端口名字转换为全局的名字（这个端口的全局数据结构的地址）。

##### 端口的数据结构
内核为每个端口维护了一个叫 kern_port_t 的数据结构。它包含以下信息：
* 对这个端口的所有权利的引用计数
* 指向持有接收权利的任务的指针
* 在接受者任务中的端口本地名字
* 指向备份端口指针。如果端口被释放了，备份端口会接收发往该端口的所有消息。
* 消息的双向链表
* 被阻塞的发送者队列
* 被阻塞的接收者队列，虽然只有单个任务拥有接收权利，但该任务的很多线程可能正在等待接收消息。
* 对这个对象的所有转换的链表
* 指向端口集合的指针
* 当前队列里的消息计数
* 队列里允许的最大消息数目

##### 端口转换
Mach为每个端口权利维护了一个转换条目，转换条目必须由一个由<task, port, local_name, type>元组组成的集合，这里的task是拥有权利的任务，port为指向端口的内核数据结构的指针，local_name是task内端口的名字，type为发送或接收。
* msg_send 必须将<task, local_name>转换为端口。
* msg_rcv 必须将<task, port> 转换为local_name。

Mach2.5使用了两个全局的散列表来快速的查找条目，TP_table基于<task, port>进行散列计算，TL_table基于<task, local_name>进行散列计算。

##### 消息传递
单个消息传递需要的操作：
1）发送者在自己的地址空间上创建消息。
2）发送者执行msg_send 系统调用来发送消息，消息头部包含目的端口。
3）内核将消息复制到内部数据结构（kern_msg_t）中，端口权利被转换为指向端口的内核对象的指针。同时，out-of-line 内存会被复制进一个暂存映射表中。
4）a、如果线程正在等待接收消息，（线程在这个端口被阻塞的接收者队列中），它会被唤醒，该消息会直接发送给它。
      b、否则，如果这个端口的消息队列满了，发送者会一直阻塞，直到有消息从队列中移除。
      c、否则，消息就在端口上排队，直到有接受者任务里的线程执行 msg_rcv。
5）一但消息已经入队或者给予接收者，内核就会从msg_send 中返回。
6）当接收者调用msg_rcv时，内核将消息从队列中移除。如果队列是空的，接收者会一直阻塞，直到有消息到达。
7）内核将消息复制进接收者的地址空间，这也会执行后续对 out-of-line 和端口权利的转换。
8）接收者如果期望答复，接收者必须具有对发送者所拥有端口的发送权利。发送者使用消息头部里的replyport字段将发送权利发送给接收者。

![](https://github.com/Yanyuxxxx/Blogs/blob/master/images/03_%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5.png?raw=true)



参考资料：
《深入理解UNIX系统内核》
《深入解析MAC OS & iOS 操作系统》


