# 深入浅出UNIX系统内核（一）



## 一、内核
#### 1、内核是什么？
内核是一个特殊的程序，可以直接运行在设备上。他实现了进程模型和其他系统服务。

> 内核驻留在磁盘中的一个文件中。当系统启动时，使用称为引导的特殊过程从磁盘上加载内核。接着，内核初始化系统，为进程运行设置环境。然后，创建几个初始进程，这些进程随后依次创建其他进程，一旦加载完成，内核会一直驻留在内存中，直到系统关闭。他管理着所有的进程，为进程提供各种服务

下图展示了MAC OS & iOS的XNU内核

![](https://github.com/Yanyuxxxx/Blogs/blob/master/images/02_Darwin%E6%9E%B6%E6%9E%84.png?raw=true)

#### 2、虚拟内存
在虚拟内存系统中，程序使用的地址不会直接引用物理内存中的位置，每个进程都有自己的虚拟内存地址空间，通过使用一组地址转换映射表，将虚拟内存地址的引用转换为物理内存中的位置。计算机的内存管理单元（MMU）通常会有一组寄存器来标识当前正在运行进程的转换映射表。在当前进程将CPU让给另外一个进程时（即发生了上下文切换），内核会将这些寄存器和指针加载到新进程的转换映射表中。MMU寄存器是受特权保护的，只能在内核态下访问。这就确保一个进程只能引用它自己空间中的地址，而不能访问或者修改其他进程的地址空间。

每个进程的虚拟地址空间有一个固定的部分映射为内核的代码和数据结构内容。该部分称为系统空间或内核空间，只能在内核态下访问。在系统中，因为只有一个内核实例在运行，所有进程都映射到了单个内核地址空间上。

#### 3、内核态与用户态
内核是一个受信任的系统组件，控制着最为关键的功能。内核的功能和应用程序的功能之间需要有一种严格的分离，否则，应用程序的不稳定可能会使整个系统崩溃。
内核态和用户态可以理解为程序的运行权限，系统调用和中断处理都会将程序由用户态转换为内核态。

> inter架构使用4个 “ring”表示权限级别，ring0对应的是内核态，ring3对应的是用户态。ring1和ring2预留给操作系统服务使用。
> ARM处理器使用了一个特殊的寄存器—当前程序状态寄存器（CPSR），来定义处理器所在的模式



## 二、进程

进程是一个实体，运行一个程序并为它提供一个可执行的环境。进程包含一个地址空间和一个控制点，进程是基本的调度实体，在CPU上一次只能运行一个进程。（UNIX进程模型）

> 控制点：进程的控制点通过使用一个叫程序计数器的硬件寄存器来跟踪指令序列。很多后期的UNIX版本在单个进程中支持多个控制点（称为线程），因此一个进程内可以支持多个指令序列

#### 进程状态

1）fork系统调用创建一个新的进程，最开始是初始状态，完全创建完成后，fork将其转换到就绪状态，在这里进程必须等待被调度。最后内核选择了执行该进程，发起一个上下文切换，将进程的硬件上下文加载到系统寄存器中，并将控制权转给进程。（调度）

2）当进程被安排调度运行时，它首先运行在内核态（内核运行状态）中，在这里完成上下文切换。下一个转换取决于进程被切换出去之前所做的事情。如果进程是被新创建的或者正在执行用户的代码（并由于为了让更高优先级的进程先运行而被取消调度），会立刻回到用户态。如果他在执行某个系统调用而被阻塞，它会在内核态下恢复该系统调用的执行。

3）最后，进程调用exit系统调用或者由于信号（signal，内核所发出的通知）而终止。 — 进程处于僵死状态

4）父进程调用wait（或者其他wait变种）后，销毁进程，退出状态返回给进程。

下图为进程状态和状态转换：

![](https://github.com/Yanyuxxxx/Blogs/blob/master/images/02_%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8C%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png?raw=true)

#### 每进程对象（per-process）：
内核维护了一些全局数据结构和一些每进程对象。每进程对象包含了允许内核访问任何进程地址空间的信息。
#### u区和proc结构：
有关进程的控制信息保存在两个每进程的数据结构中：u区和proc结构。

在很多实现上，内核有一个固定大小的proc结构数组，称为进程表。由于proc结构是在系统空间里的，所以任何时候proc结构对内核都是可见，即便在进程没有运行时。

而u区是进程空间的一部分，也就是说只有进程运行时他才会被映射，才是可见的。
#### 内核栈：
UNIX内核是可重入的，意味着多个进程可以并发的参与内核的活动。因此每个进程需要它自己的私有内核栈来跟踪它在内核中执行时的函数调用序列。许多UNIX实现是在每个进程的地址空间中分配内核栈，但并不允许用户态对内核栈的访问。



## 二、线程与轻量级进程

#### 进程模型的局限性
很应用程序希望并发的执行一些大型的独立任务，但又必须与其他进程共享同一个公共的地址空间和其他资源。
传统的进程无法充分利用多处理器体系架构的优点，因为在一个时刻只能使用一个处理器。
很多应用程序必须执行大量独立且不需要串行化的任务。如果系统可以提供子任务并发执行的机制，这些应用程序将会运行的更好。

#### 线程
线程表示进程中的一个控制点，并执行一系列指令。进程中的所有线程共享着相同的地址空间。

每个线程还有自己的私有对象，如程序计数器，栈和寄存器上下文。

#### 几种重要的不同类型的线程
##### 1）内核线程
内核线程不需要与用户进程关联，它由内核内部根据需要创建和销毁，负责执行一个特殊的功能。内核线程共享了内核的代码和全局数据，有自己自己的内核栈。内核线程可以被独立的调度，和使用标准的内核同步机制，如sleep()和wakeup()。

内核线程并不是一个新的概念。传统的UNIX内核中的pagedaemon这样的系统进程在功能上与内核线程是等价的。

##### 2）轻量级进程(LWP)
轻量级进程，是由内核支持的用户线程，它是基于内核线程更高级别的抽象，因此一个系统，必须在可以支持LWP之前支持内核线程，每个进程可以有一个或多个LWP，每个LWP由一个单独的内核线程来支持。调度器通过调度内核线程来调度LWP，LWP共享进程的地址空间和其他资源。
![](https://github.com/Yanyuxxxx/Blogs/blob/master/images/02_%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B.png?raw=true)

#### Mach的线程
Mach支持处理器集合的概念，系统上可用的处理器可以被分为不重叠的处理器集合。每个任务和线程可以被分配到任意处理器集合。这允许多处理器系统上的一些CPU专用于一个或多个特定的任务，从而保证高优先级任务的资源需求。
##### Mach的抽象：任务和线程
###### 任务
任务（task）是一个静态的对象，由一个地址空间和一组叫端口权利（port right）的系统资源集合组成。任务本身并不是一个可执行的实体，仅仅是可供一个或多个线程执行的环境。
###### 线程
线程是基本的执行单元，运行在任务的上下文中。每个任务可以包含零个或多个线程，线程都共享着任务的资源。每个线程有一个内核栈，用于系统调用处理，线程还有自己的计算状态（程序计数器、栈指针、通用寄存器等），而且是被处理器独立的调度。属于用户任务的线程等价于轻量级进程（每个用户线程会在底层关联一个内核线程uthread），纯内核线程属于内核任务。


